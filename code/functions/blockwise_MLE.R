# these functions are for fitting local MLEs at each location. See paper for
# details on model.

#' Subset coordinate blocks of data by latitude and longitude.
#'
#' function for finding locations that fall within latitude and longitude degree
#' blocks. The ouptut will be used to extract columns of data for MLE fitting.
#'
#' @param coord_dt data.table input with columns lon, lat, location
#' (index value). See extract_coord_dt() for extracting correct input.
#' @param indx This gives the location index for the center of the data block.
#' Valid values of indx will come from the location column of coord_dt.
#' @param lat_margin gives the number of degrees latitude of margin to extract
#' on either side of the central point.
#' @param lon_margin gives the number of degrees longitude of margin to extract
#' on either side of the central point.
#' @returns a data.table subset of coord_dt that includes lon/lat/location
#' columns for the rows of locations falling within the specified box.

find_lat_lon_block <- function(coord_dt, indx, lat_margin = 10, lon_margin = 10) {
  center_lon <- coord_dt[indx]$lon
  center_lat <- coord_dt[indx]$lat
  if (center_lon + lon_margin >= 360) {
    subset_dt <- coord_dt[((lat >= center_lat - lat_margin) &
                             (lat <= center_lat + lat_margin)) &
                            (((lon >= center_lon - lon_margin) & lon <= 358) |
                               ((lon >= 0) & (lon <= ((center_lon + lon_margin) %% 360))
                                              ))]
  } else if (center_lon - lon_margin < 0) {
    subset_dt <- coord_dt[((lat >= center_lat - lat_margin) & (lat <= center_lat + lat_margin)) &
                            ((lon >= 0 & lon <= center_lon + lon_margin) |
                               (lon >= ((center_lon - lon_margin) %% 360) & lon <= 358))]
  } else {
    subset_dt <- coord_dt[(lat >= center_lat - lat_margin) &
                            (lat <= center_lat + lat_margin) &
                            (lon >= center_lon - lon_margin) &
                            (lon <= center_lon + lon_margin)]
  }
  return(subset_dt)
}

#' Find location indices for grid boxes falling within a latitude longitude box
#'
#' function for finding location indices for points that fall within a latitude
#' and longitude degree block of a specified central point. Useful for generating
#' matrix of indices when making covariance weights for covariance weighted
#' smoothing.
#'
#' @param coord_dt data.table input with columns lon, lat, location
#' (index value). See extract_coord_dt() for extracting correct input.
#' @param indx This gives the location index for the center of the data block.
#' Valid values of indx will come from the location column of coord_dt.
#' @param lat_margin gives the number of degrees latitude of margin to extract
#' on either side of the central point.
#' @param lon_margin gives the number of degrees longitude of margin to extract
#' on either side of the central point.
#' @returns a vector subset of coord_dt$location that includes locations for the
#' elements falling within the specified box.

find_lat_lon_block_indx <- function(coord_dt, indx, lat_margin = 10, lon_margin = 10) {
  center_lon <- coord_dt[indx]$lon
  center_lat <- coord_dt[indx]$lat

  if (center_lon + lon_margin >= 360) {
    subset_dt <- coord_dt[((lat >= center_lat - lat_margin) &
                             (lat <= center_lat + lat_margin)) &
                            (((lon >= center_lon - lon_margin) & lon <= 358) |
                               ((lon >= 0) & (lon <= ((center_lon + lon_margin) %% 360))
                               ))]
  } else if (center_lon - lon_margin < 0) {
    subset_dt <- coord_dt[((lat >= center_lat - lat_margin) & (lat <= center_lat + lat_margin)) &
                            ((lon >= 0 & lon <= center_lon + lon_margin) |
                               (lon >= ((center_lon - lon_margin) %% 360) & lon <= 358))]
  } else {
    subset_dt <- coord_dt[(lat >= center_lat - lat_margin) &
                            (lat <= center_lat + lat_margin) &
                            (lon >= center_lon - lon_margin) &
                            (lon <= center_lon + lon_margin)]
  }
  
  return(subset_dt$location)
}

#' Generate list of location indices for latitude, longitude boxes.
#'
#' this function generates a list of location indices for use in
#' covariance weighted smoothing.
#' @param coord_dt data.table with columns lon, lat, location as generated by
#' exract_coord_dt function.
#' @param lat_margin lat_margin to input to find_lat_lon_block_indx()
#' @param lon_margin lon_margin to input to find_lat_lon_block_indx()
#' @returns a list of length = nrow(coord_dt), where list
#' element [[i]] is a vector that contains all location indices within the
#' degree box with specified margins and central point coord_dt[[i]].

get_loc_list <- function(coord_dt, lat_margin = 10, lon_margin = 10) {
  n <- nrow(coord_dt)
  loc_list <- vector(mode = "list", length = n)
  
  for (i in 1:n) {
    loc_list[[i]] <- find_lat_lon_block_indx(coord_dt = coord_dt,
                                                  indx = coord_dt$location[i],
                                                  lat_margin = lat_margin,
                                                  lon_margin = lon_margin)
  }

  return(loc_list)
}


#' Find pairwise zonal and meridional pairwise distances between locations
#'
#' take location indices, return dist_pairs_mat of zonal and meridional distances
#' useful for creating a matrix of pairwise distances to weight by the anisotropy
#' matix. Input the signed distance matrices into the arguments.
#'
#' @param zonal_dist_mat p x p matrix of zonal distances between pairs of
#' locations. These should be signed distances if anisotropy weighting is used.
#' @param merid_dist_mat p x p matrix of meridional distances between pairs of
#' locations. These should be signed distances if anisotropy weighting is used.
#' @param loc_vec a length d vector with the particular locations at which to
#' find the paired distances.
#' @returns a d^2 x 2 matrix with the pairs of zonal distances, column 1, and
#' meridional distances, column 2. The first d pairs start by combining the first
#' location loc_vec[1] with loc_vec[1] to loc_vec[d], the next d pairs combine
#' loc_vec[2] with loc_vec[1] to loc_vec[d] in order, with the rest of the pairs
#' proceeding in the same ordering.
#'

find_dist_pairs <- function(zonal_dist_mat, merid_dist_mat, loc_vec) {
  loc_grid <- data.matrix(expand.grid(loc_vec, loc_vec)[, c(2, 1)])

  zonal_dist_sub <- zonal_dist_mat[loc_grid]
  merid_dist_sub <- merid_dist_mat[loc_grid]

  dist_pairs_mat <- cbind(zonal_dist_sub, merid_dist_sub)

  return(dist_pairs_mat)
}

#' Find pairwise zonal and meridional pairwise distances between locations
#'
#' As in find_dist_pairs() but only only calculates distance pairs between the 
#' main location given in loc parameter and the locations in loc_vec.
#' Returns dist_pairs_mat of zonal and meridional distances.
#' Useful for creating a matrix of pairwise distances to weight by the anisotropy
#' matrix. Input the signed distance matrices into the arguments.
#'
#' @param zonal_dist_mat p x p matrix of zonal distances between pairs of
#' locations. These should be signed distances if anisotropy weighting is used.
#' @param merid_dist_mat p x p matrix of meridional distances between pairs of
#' locations. These should be signed distances if anisotropy weighting is used.
#' @param loc the central location with which to find the distances.
#' @param loc_vec a length d vector with the particular locations at which to
#' find the distances from the central location.
#' @returns a d x 2 matrix with the pairs of zonal distances, column 1, and
#' meridional distances, column 2. The distances are calculated between the 
#' location in loc and the locations in loc_vec in order.
#'

find_local_dist_pairs <- function(zonal_dist_mat, merid_dist_mat, loc, loc_vec) {
  loc_grid <- cbind(loc, loc_vec)

  zonal_dist_sub <- zonal_dist_mat[loc_grid]
  merid_dist_sub <- merid_dist_mat[loc_grid]

  dist_pairs_mat <- cbind(zonal_dist_sub, merid_dist_sub)

  return(dist_pairs_mat)
}

#' Find matern-1/2 likelihood of inputted data
#'
#' This function is for use in optim to solve maximum likelihood problem for
#' subsetted blocks.
#'
#' @param par parameter vector with three elements. The first is phi the range
#' paramter of the matern covariance function, the second is the anisotropy angle,
#' the third is the anisotropy ratio. See find_aniso_matrix() and paper for more
#' details.
#' @param data_mat_sub the subsetted data on which to find the likelihood.
#' @param dist_pairs_mat the matrix of pairwise distances between the locations.
#' @returns matern-1/2 likelihood calculated with the given parameters and data.
#'
m0.5_lik <- function(par, data_mat_sub, dist_pairs_mat) {
  phi <- par[1]
  ani_angle <- par[2]
  ani_ratio <- par[3]

  p <- ncol(data_mat_sub)
  n <- nrow(data_mat_sub)

  aniso_mat <- find_aniso_mat(aniso_angle = ani_angle,
                              aniso_ratio = ani_ratio)

  w_dist <- sqrt(rowSums((dist_pairs_mat %*% aniso_mat) * dist_pairs_mat))
  wdist_mat <- matrix(w_dist, nrow = p)

  cov_mat <- matern_0.5_cov(wdist_mat, phi = phi)
  cov_inv <- solve(cov_mat)

  likelihood <- -0.5 * (n * determinant(cov_mat)$modulus +
                          sum((data_mat_sub %*% cov_inv) * data_mat_sub))
  
  return(likelihood)
}

#' Find matern-3/2 likelihood of inputted data
#'
#' This function is for use in optim to solve maximum likelihood problem for
#' subsetted blocks.
#'
#' @param par parameter vector with three elements. The first is phi the range
#' paramter of the matern covariance function, the second is the anisotropy angle,
#' the third is the anisotropy ratio. See find_aniso_matrix() and paper for more
#' details.
#' @param data_mat_sub the subsetted data on which to find the likelihood.
#' @param dist_pairs_mat the matrix of pairwise distances between the locations.
#' @returns matern-3/2 likelihood calculated with the given parameters and data.
#'

m1.5_lik <- function(par, data_mat_sub, dist_pairs_mat) {
  phi <- par[1]
  ani_angle <- par[2]
  ani_ratio <- par[3]

  p <- ncol(data_mat_sub)
  n <- nrow(data_mat_sub)

  aniso_mat <- find_aniso_mat(aniso_angle = ani_angle,
                              aniso_ratio = ani_ratio)

  w_dist <- sqrt(rowSums((dist_pairs_mat %*% aniso_mat) * dist_pairs_mat))

  wdist_mat <- matrix(w_dist, nrow = p)

  cov_mat <- matern_1.5_cov(wdist_mat, sigma2 = 1, phi = phi)
  cov_inv <- solve(cov_mat)

  # by default the determinant() returns the logarithm of the modulus.
  # the below calculation inside the sum gives a matrix whose row sums
  # equal the quadratic forms of each observation with the inv. cov. matrix.
  # taking the sum of the whole matrix gives the sum across the n observations.

  likelihood <- -0.5 * (n * determinant(cov_mat)$modulus +
                          sum((data_mat_sub %*% cov_inv) * data_mat_sub))

  return(likelihood)

}

#' Find local MLE parameter estimates
#'
#' Fitting function for finding localized MLEs. These are used downstream in
#' the covariance weighted smoothing algorithm. By default 20 degree by 20
#' degree blocks centered at the target location are used for fitting.
#'
#' @param loc integer index for the location, see extract_coord_dt() for details.
#' Equivalent to the column index in the data matrices.
#' @param coord_dt data.table with lon/lat/location variables. Produced by
#' extract_coord_dt().
#' @param lat_margin the number of degrees margin on either side of
#' the location to extract data for fitting.
#' @param lon_margin the number of degrees margin on either side of the location
#' extract data for fitting.
#' @param zonal_dist_mat signed distance matrix in the E-W (zonal) direction.
#' see find_signed_zonal_dist()
#' @param merid_dist_mat signed distance matrix in the N-S (meridional) direction.
#' See find_signed_merid_dist().
#' @param data_mat_std n x p data matrix where n is the number of time points and
#' p is the number of grid boxes. Columns should be standardized to sd 1.
#' @param init_cond length 3 vector containing the initial conditions for the
#' optimization routine. Element 1 is phi, the overall correlation length scale,
#' element 2 is the anisotropy angle, element 3 is the anistropy ratio. See
#' find_aniso_mat() and m1.5_lik() for details. Can also supply a matrix,
#' in which a separate optimization is performed from each initial condition.
#' @returns a vector containing the results of the optimization and the value of
#' the fitted likelihood. Element 1 is phi, the overall correlation length scale,
#' element 2 is the anisotropy angle, element 3 is the anistropy ratio, and
#' element 4 is the likelihood value. See find_aniso_matrix() and m1.5_lik() for details.

find_local_MLE <- function(loc,
                           coord_dt,
                           lat_margin = 10,
                           lon_margin = 10,
                           zonal_dist_mat,
                           merid_dist_mat,
                           data_mat_std,
                           lik_func = m1.5_lik,
                           return_best = TRUE,
                           return_likelihood = TRUE,
                           init_cond = c(1, pi/2, 1.5)) {

  sub_coord_dt <- find_lat_lon_block(coord_dt,
                                     loc,
                                     lat_margin = lat_margin,
                                     lon_margin = lon_margin)

  test_pairs_mat <- find_dist_pairs(zonal_dist_mat = zonal_dist_mat,
                                    merid_dist_mat = merid_dist_mat,
                                    loc_vec = sub_coord_dt$location)

  data_sub <- data_mat_std[, sub_coord_dt$location]

  #if the init_cond input has no dimensions then run once,
  # else run an optimization for each row of init_cond.

  if (is.null(dim(init_cond))) {
    optim_out <- tryCatch(
      expr = optim(par = init_cond,
                   fn = lik_func,
                   control = list(fnscale = -1),
                   data_mat_sub = data_sub,
                   dist_pairs_mat = test_pairs_mat,
                   method = "L-BFGS-B",
                   lower = c(0, 0, 1),
                   upper = c(Inf, pi, Inf)),
      error = function(cond) {
        warning("Possible error at location ",
                loc,
                ". Init. cond.: ",
                i,
                ".")
        return(NA)
      }
    )

    if (any(is.na(optim_out))) {
      phi_out <- NA
      ani_ang_out <- NA
      ani_rat_out <- NA
      lik_out <- NA
      conv_out <- NA
    } else {
        if (optim_out$convergence != 0) {
          warning("optim convergence status was ",
                         optim_out$convergence,
                         " at location ",
                         loc,
                         " . ",
                         optim_out$message)
                  
      }
      phi_out <- optim_out$par[1]
      ani_ang_out <- optim_out$par[2]
      ani_rat_out <- optim_out$par[3]
      lik_out <- optim_out$value
      conv_out <- optim_out$convergence
    }
    optim_results_out <- data.frame(phi = phi_out,
                                    ani_angle = ani_ang_out,
                                    ani_ratio = ani_rat_out,
                                    convergence = conv_out)

    if (return_likelihood) {
      optim_results_out$likelihood <- lik_out
    }
  }

  else {
    m <- nrow(init_cond)

    phi_out <- rep(0, m)
    ani_ang_out <- rep(0, m)
    ani_rat_out <- rep(0, m)
    lik_out <- rep(0, m)
    conv_out <- rep(0, m)

    for (i in 1:m) {
      optim_out <- tryCatch(
        expr = optim(par = init_cond[i, ],
                     fn = lik_func,
                     control = list(fnscale = -1),
                     data_mat_sub = data_sub,
                     dist_pairs_mat = test_pairs_mat,
                     method = "L-BFGS-B",
                     lower = c(0, 0, 1),
                     upper = c(Inf, pi, Inf)),
        error = function(cond) {
          warning("Possible error at location ",
                  loc,
                  ". Init. cond.: ",
                  i,
                  ".")
          return(NA)
          }
      )

      if (any(is.na(optim_out))) {
        phi_out[i] <- NA
        ani_ang_out[i] <- NA
        ani_rat_out[i] <- NA
        lik_out[i] <- NA
        conv_out[i] <- NA
      } else {
        
        # can uncomment if you want to find convergence issues for all inits.
        # Generally the best of the three convergence points does not have a 
        # non-zero optim status.
        
        # if (optim_out$convergence != 0) {
        #   warning(paste0("optim convergence status was ",
        #                  optim_out$convergence,
        #                  " at location ",
        #                  loc,
        #                  ".  ",
        #                  optim_out$message)
        #   )
        # }
        
        phi_out[i] <- optim_out$par[1]
        ani_ang_out[i] <- optim_out$par[2]
        ani_rat_out[i] <- optim_out$par[3]
        lik_out[i] <- optim_out$value
        conv_out[i] <- optim_out$convergence
      }
      }
    optim_results_out <- data.frame(phi = phi_out,
                                    ani_angle = ani_ang_out,
                                    ani_ratio = ani_rat_out,
                                    convergence = conv_out)
    if (return_likelihood) {
      optim_results_out$likelihood <- lik_out
    }
    if (return_best) {
      max_indx <- which.max(lik_out)
      
      # The following code block ensures that the likelihood maximizing parameters
      # had convergence in optim. Sometimes the maximizer has abnormal
      # termination in the linesearch algorithm of L-BFGS, but the difference
      # between the maximizer and another point with normal convergence is neglible 
      if (optim_results_out[max_indx, ]$convergence == 0) {
        optim_results_out <- optim_results_out[max_indx, ]
      } else {
        if (all(optim_results_out$convergence != 0)) {
          optim_results_out <- optim_results_out[max_indx, ]
          message("At location ",
                       loc,
                       " all inits. gave abnormal termination in L-BFGS")
        } else {
          conv_max_indx <- which.max(lik_out[conv_out == 0])
          rel_lik_diff <- ((lik_out[max_indx] - lik_out[conv_out == 0][conv_max_indx]) / 
                             lik_out[max_indx])
          if (rel_lik_diff > 1e-8) {
            message("Converged likelihood is greater than 1e-8 ",
                         "in rel. diff. from max likelihood ",
                         "at location ",
                         loc)
          }
          optim_results_out <- optim_results_out[conv_out == 0, ][conv_max_indx, ]
        }
      }
    }
  }
  return(optim_results_out)
}

